"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.didDocument = exports.getServiceEndpoint = exports.getNotifEndpoint = exports.getFeedGenEndpoint = exports.getPdsEndpoint = exports.getSigningDidKey = exports.getVerificationMaterial = exports.getSigningKey = exports.getHandle = exports.getDid = exports.isValidDidDoc = void 0;
const zod_1 = require("zod");
// Parsing atproto data
// --------
const isValidDidDoc = (doc) => {
    return exports.didDocument.safeParse(doc).success;
};
exports.isValidDidDoc = isValidDidDoc;
const getDid = (doc) => {
    const id = doc.id;
    if (typeof id !== 'string') {
        throw new Error('No `id` on document');
    }
    return id;
};
exports.getDid = getDid;
const getHandle = (doc) => {
    const aka = doc.alsoKnownAs;
    if (!aka)
        return undefined;
    const found = aka.find((name) => name.startsWith('at://'));
    if (!found)
        return undefined;
    // strip off at:// prefix
    return found.slice(5);
};
exports.getHandle = getHandle;
// @NOTE we parse to type/publicKeyMultibase to avoid the dependency on @atproto/crypto
const getSigningKey = (doc) => {
    return (0, exports.getVerificationMaterial)(doc, 'atproto');
};
exports.getSigningKey = getSigningKey;
const getVerificationMaterial = (doc, keyId) => {
    const did = (0, exports.getDid)(doc);
    let keys = doc.verificationMethod;
    if (!keys)
        return undefined;
    if (typeof keys !== 'object')
        return undefined;
    if (!Array.isArray(keys)) {
        keys = [keys];
    }
    const found = keys.find((key) => key.id === `#${keyId}` || key.id === `${did}#${keyId}`);
    if (!found?.publicKeyMultibase)
        return undefined;
    return {
        type: found.type,
        publicKeyMultibase: found.publicKeyMultibase,
    };
};
exports.getVerificationMaterial = getVerificationMaterial;
const getSigningDidKey = (doc) => {
    const parsed = (0, exports.getSigningKey)(doc);
    if (!parsed)
        return;
    return `did:key:${parsed.publicKeyMultibase}`;
};
exports.getSigningDidKey = getSigningDidKey;
const getPdsEndpoint = (doc) => {
    return (0, exports.getServiceEndpoint)(doc, {
        id: '#atproto_pds',
        type: 'AtprotoPersonalDataServer',
    });
};
exports.getPdsEndpoint = getPdsEndpoint;
const getFeedGenEndpoint = (doc) => {
    return (0, exports.getServiceEndpoint)(doc, {
        id: '#bsky_fg',
        type: 'BskyFeedGenerator',
    });
};
exports.getFeedGenEndpoint = getFeedGenEndpoint;
const getNotifEndpoint = (doc) => {
    return (0, exports.getServiceEndpoint)(doc, {
        id: '#bsky_notif',
        type: 'BskyNotificationService',
    });
};
exports.getNotifEndpoint = getNotifEndpoint;
const getServiceEndpoint = (doc, opts) => {
    const did = (0, exports.getDid)(doc);
    let services = doc.service;
    if (!services)
        return undefined;
    if (typeof services !== 'object')
        return undefined;
    if (!Array.isArray(services)) {
        services = [services];
    }
    const found = services.find((service) => service.id === opts.id || service.id === `${did}${opts.id}`);
    if (!found)
        return undefined;
    if (opts.type && found.type !== opts.type) {
        return undefined;
    }
    if (typeof found.serviceEndpoint !== 'string') {
        return undefined;
    }
    return validateUrl(found.serviceEndpoint);
};
exports.getServiceEndpoint = getServiceEndpoint;
// Check protocol and hostname to prevent potential SSRF
const validateUrl = (urlStr) => {
    let url;
    try {
        url = new URL(urlStr);
    }
    catch {
        return undefined;
    }
    if (!['http:', 'https:'].includes(url.protocol)) {
        return undefined;
    }
    else if (!url.hostname) {
        return undefined;
    }
    else {
        return urlStr;
    }
};
// Types
// --------
const verificationMethod = zod_1.z.object({
    id: zod_1.z.string(),
    type: zod_1.z.string(),
    controller: zod_1.z.string(),
    publicKeyMultibase: zod_1.z.string().optional(),
});
const service = zod_1.z.object({
    id: zod_1.z.string(),
    type: zod_1.z.string(),
    serviceEndpoint: zod_1.z.union([zod_1.z.string(), zod_1.z.record(zod_1.z.unknown())]),
});
exports.didDocument = zod_1.z.object({
    id: zod_1.z.string(),
    alsoKnownAs: zod_1.z.array(zod_1.z.string()).optional(),
    verificationMethod: zod_1.z.array(verificationMethod).optional(),
    service: zod_1.z.array(service).optional(),
});
//# sourceMappingURL=did-doc.js.map