"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BskyAgent = void 0;
const syntax_1 = require("@atproto/syntax");
const agent_1 = require("./agent");
const client_1 = require("./client");
const labels_1 = require("./moderation/const/labels");
const util_1 = require("./util");
const moderation_1 = require("./moderation");
const FEED_VIEW_PREF_DEFAULTS = {
    hideReplies: false,
    hideRepliesByUnfollowed: true,
    hideRepliesByLikeCount: 0,
    hideReposts: false,
    hideQuotePosts: false,
};
const THREAD_VIEW_PREF_DEFAULTS = {
    sort: 'oldest',
    prioritizeFollowedUsers: true,
};
class BskyAgent extends agent_1.AtpAgent {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "getTimeline", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (params, opts) => this.api.app.bsky.feed.getTimeline(params, opts)
        });
        Object.defineProperty(this, "getAuthorFeed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (params, opts) => this.api.app.bsky.feed.getAuthorFeed(params, opts)
        });
        Object.defineProperty(this, "getActorLikes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (params, opts) => this.api.app.bsky.feed.getActorLikes(params, opts)
        });
        Object.defineProperty(this, "getPostThread", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (params, opts) => this.api.app.bsky.feed.getPostThread(params, opts)
        });
        Object.defineProperty(this, "getPost", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (params) => this.api.app.bsky.feed.post.get(params)
        });
        Object.defineProperty(this, "getPosts", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (params, opts) => this.api.app.bsky.feed.getPosts(params, opts)
        });
        Object.defineProperty(this, "getLikes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (params, opts) => this.api.app.bsky.feed.getLikes(params, opts)
        });
        Object.defineProperty(this, "getRepostedBy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (params, opts) => this.api.app.bsky.feed.getRepostedBy(params, opts)
        });
        Object.defineProperty(this, "getFollows", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (params, opts) => this.api.app.bsky.graph.getFollows(params, opts)
        });
        Object.defineProperty(this, "getFollowers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (params, opts) => this.api.app.bsky.graph.getFollowers(params, opts)
        });
        Object.defineProperty(this, "getProfile", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (params, opts) => this.api.app.bsky.actor.getProfile(params, opts)
        });
        Object.defineProperty(this, "getProfiles", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (params, opts) => this.api.app.bsky.actor.getProfiles(params, opts)
        });
        Object.defineProperty(this, "getSuggestions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (params, opts) => this.api.app.bsky.actor.getSuggestions(params, opts)
        });
        Object.defineProperty(this, "searchActors", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (params, opts) => this.api.app.bsky.actor.searchActors(params, opts)
        });
        Object.defineProperty(this, "searchActorsTypeahead", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (params, opts) => this.api.app.bsky.actor.searchActorsTypeahead(params, opts)
        });
        Object.defineProperty(this, "listNotifications", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (params, opts) => this.api.app.bsky.notification.listNotifications(params, opts)
        });
        Object.defineProperty(this, "countUnreadNotifications", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (params, opts) => this.api.app.bsky.notification.getUnreadCount(params, opts)
        });
        Object.defineProperty(this, "getLabelers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (params, opts) => this.api.app.bsky.labeler.getServices(params, opts)
        });
    }
    clone() {
        const inst = new BskyAgent({
            service: this.service,
        });
        this.copyInto(inst);
        return inst;
    }
    get app() {
        return this.api.app;
    }
    async getLabelDefinitions(prefs) {
        // collect the labeler dids
        let dids = BskyAgent.appLabelers;
        if (isBskyPrefs(prefs)) {
            dids = dids.concat(prefs.moderationPrefs.labelers.map((l) => l.did));
        }
        else if (isModPrefs(prefs)) {
            dids = dids.concat(prefs.labelers.map((l) => l.did));
        }
        else {
            dids = dids.concat(prefs);
        }
        // fetch their definitions
        const labelers = await this.getLabelers({
            dids,
            detailed: true,
        });
        // assemble a map of labeler dids to the interpretted label value definitions
        const labelDefs = {};
        if (labelers.data) {
            for (const labeler of labelers.data
                .views) {
                labelDefs[labeler.creator.did] = (0, moderation_1.interpretLabelValueDefinitions)(labeler);
            }
        }
        return labelDefs;
    }
    async post(record) {
        if (!this.session) {
            throw new Error('Not logged in');
        }
        record.createdAt = record.createdAt || new Date().toISOString();
        return this.api.app.bsky.feed.post.create({ repo: this.session.did }, record);
    }
    async deletePost(postUri) {
        if (!this.session) {
            throw new Error('Not logged in');
        }
        const postUrip = new syntax_1.AtUri(postUri);
        return await this.api.app.bsky.feed.post.delete({
            repo: postUrip.hostname,
            rkey: postUrip.rkey,
        });
    }
    async like(uri, cid) {
        if (!this.session) {
            throw new Error('Not logged in');
        }
        return await this.api.app.bsky.feed.like.create({ repo: this.session.did }, {
            subject: { uri, cid },
            createdAt: new Date().toISOString(),
        });
    }
    async deleteLike(likeUri) {
        if (!this.session) {
            throw new Error('Not logged in');
        }
        const likeUrip = new syntax_1.AtUri(likeUri);
        return await this.api.app.bsky.feed.like.delete({
            repo: likeUrip.hostname,
            rkey: likeUrip.rkey,
        });
    }
    async repost(uri, cid) {
        if (!this.session) {
            throw new Error('Not logged in');
        }
        return await this.api.app.bsky.feed.repost.create({ repo: this.session.did }, {
            subject: { uri, cid },
            createdAt: new Date().toISOString(),
        });
    }
    async deleteRepost(repostUri) {
        if (!this.session) {
            throw new Error('Not logged in');
        }
        const repostUrip = new syntax_1.AtUri(repostUri);
        return await this.api.app.bsky.feed.repost.delete({
            repo: repostUrip.hostname,
            rkey: repostUrip.rkey,
        });
    }
    async follow(subjectDid) {
        if (!this.session) {
            throw new Error('Not logged in');
        }
        return await this.api.app.bsky.graph.follow.create({ repo: this.session.did }, {
            subject: subjectDid,
            createdAt: new Date().toISOString(),
        });
    }
    async deleteFollow(followUri) {
        if (!this.session) {
            throw new Error('Not logged in');
        }
        const followUrip = new syntax_1.AtUri(followUri);
        return await this.api.app.bsky.graph.follow.delete({
            repo: followUrip.hostname,
            rkey: followUrip.rkey,
        });
    }
    async upsertProfile(updateFn) {
        if (!this.session) {
            throw new Error('Not logged in');
        }
        let retriesRemaining = 5;
        while (retriesRemaining >= 0) {
            // fetch existing
            const existing = await this.com.atproto.repo
                .getRecord({
                repo: this.session.did,
                collection: 'app.bsky.actor.profile',
                rkey: 'self',
            })
                .catch((_) => undefined);
            // run the update
            const updated = await updateFn(existing?.data.value);
            if (updated) {
                updated.$type = 'app.bsky.actor.profile';
            }
            // validate the record
            const validation = client_1.AppBskyActorProfile.validateRecord(updated);
            if (!validation.success) {
                throw validation.error;
            }
            try {
                // attempt the put
                await this.com.atproto.repo.putRecord({
                    repo: this.session.did,
                    collection: 'app.bsky.actor.profile',
                    rkey: 'self',
                    record: updated,
                    swapRecord: existing?.data.cid || null,
                });
            }
            catch (e) {
                if (retriesRemaining > 0 &&
                    e instanceof client_1.ComAtprotoRepoPutRecord.InvalidSwapError) {
                    // try again
                    retriesRemaining--;
                    continue;
                }
                else {
                    throw e;
                }
            }
            break;
        }
    }
    async mute(actor) {
        return this.api.app.bsky.graph.muteActor({ actor });
    }
    async unmute(actor) {
        return this.api.app.bsky.graph.unmuteActor({ actor });
    }
    async muteModList(uri) {
        return this.api.app.bsky.graph.muteActorList({
            list: uri,
        });
    }
    async unmuteModList(uri) {
        return this.api.app.bsky.graph.unmuteActorList({
            list: uri,
        });
    }
    async blockModList(uri) {
        if (!this.session) {
            throw new Error('Not logged in');
        }
        return await this.api.app.bsky.graph.listblock.create({ repo: this.session.did }, {
            subject: uri,
            createdAt: new Date().toISOString(),
        });
    }
    async unblockModList(uri) {
        if (!this.session) {
            throw new Error('Not logged in');
        }
        const listInfo = await this.api.app.bsky.graph.getList({
            list: uri,
            limit: 1,
        });
        if (!listInfo.data.list.viewer?.blocked) {
            return;
        }
        const { rkey } = new syntax_1.AtUri(listInfo.data.list.viewer.blocked);
        return await this.api.app.bsky.graph.listblock.delete({
            repo: this.session.did,
            rkey,
        });
    }
    async updateSeenNotifications(seenAt) {
        seenAt = seenAt || new Date().toISOString();
        return this.api.app.bsky.notification.updateSeen({
            seenAt,
        });
    }
    async getPreferences() {
        const prefs = {
            feeds: {
                saved: undefined,
                pinned: undefined,
            },
            feedViewPrefs: {
                home: {
                    ...FEED_VIEW_PREF_DEFAULTS,
                },
            },
            threadViewPrefs: { ...THREAD_VIEW_PREF_DEFAULTS },
            moderationPrefs: {
                adultContentEnabled: false,
                labels: { ...labels_1.DEFAULT_LABEL_SETTINGS },
                labelers: BskyAgent.appLabelers.map((did) => ({ did, labels: {} })),
                mutedWords: [],
                hiddenPosts: [],
            },
            birthDate: undefined,
            interests: {
                tags: [],
            },
        };
        const res = await this.app.bsky.actor.getPreferences({});
        const labelPrefs = [];
        for (const pref of res.data.preferences) {
            if (client_1.AppBskyActorDefs.isAdultContentPref(pref) &&
                client_1.AppBskyActorDefs.validateAdultContentPref(pref).success) {
                // adult content preferences
                prefs.moderationPrefs.adultContentEnabled = pref.enabled;
            }
            else if (client_1.AppBskyActorDefs.isContentLabelPref(pref) &&
                client_1.AppBskyActorDefs.validateContentLabelPref(pref).success) {
                // content label preference
                const adjustedPref = adjustLegacyContentLabelPref(pref);
                labelPrefs.push(adjustedPref);
            }
            else if (client_1.AppBskyActorDefs.isLabelersPref(pref) &&
                client_1.AppBskyActorDefs.validateLabelersPref(pref).success) {
                // labelers preferences
                prefs.moderationPrefs.labelers = BskyAgent.appLabelers
                    .map((did) => ({ did, labels: {} }))
                    .concat(pref.labelers.map((labeler) => ({
                    ...labeler,
                    labels: {},
                })));
            }
            else if (client_1.AppBskyActorDefs.isSavedFeedsPref(pref) &&
                client_1.AppBskyActorDefs.validateSavedFeedsPref(pref).success) {
                // saved and pinned feeds
                prefs.feeds.saved = pref.saved;
                prefs.feeds.pinned = pref.pinned;
            }
            else if (client_1.AppBskyActorDefs.isPersonalDetailsPref(pref) &&
                client_1.AppBskyActorDefs.validatePersonalDetailsPref(pref).success) {
                // birth date (irl)
                if (pref.birthDate) {
                    prefs.birthDate = new Date(pref.birthDate);
                }
            }
            else if (client_1.AppBskyActorDefs.isFeedViewPref(pref) &&
                client_1.AppBskyActorDefs.validateFeedViewPref(pref).success) {
                // feed view preferences
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const { $type, feed, ...v } = pref;
                prefs.feedViewPrefs[pref.feed] = { ...FEED_VIEW_PREF_DEFAULTS, ...v };
            }
            else if (client_1.AppBskyActorDefs.isThreadViewPref(pref) &&
                client_1.AppBskyActorDefs.validateThreadViewPref(pref).success) {
                // thread view preferences
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const { $type, ...v } = pref;
                prefs.threadViewPrefs = { ...prefs.threadViewPrefs, ...v };
            }
            else if (client_1.AppBskyActorDefs.isInterestsPref(pref) &&
                client_1.AppBskyActorDefs.validateInterestsPref(pref).success) {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const { $type, ...v } = pref;
                prefs.interests = { ...prefs.interests, ...v };
            }
            else if (client_1.AppBskyActorDefs.isMutedWordsPref(pref) &&
                client_1.AppBskyActorDefs.validateMutedWordsPref(pref).success) {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const { $type, ...v } = pref;
                prefs.moderationPrefs.mutedWords = v.items;
            }
            else if (client_1.AppBskyActorDefs.isHiddenPostsPref(pref) &&
                client_1.AppBskyActorDefs.validateHiddenPostsPref(pref).success) {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const { $type, ...v } = pref;
                prefs.moderationPrefs.hiddenPosts = v.items;
            }
        }
        // apply the label prefs
        for (const pref of labelPrefs) {
            if (pref.labelerDid) {
                const labeler = prefs.moderationPrefs.labelers.find((labeler) => labeler.did === pref.labelerDid);
                if (!labeler)
                    continue;
                labeler.labels[pref.label] = pref.visibility;
            }
            else {
                prefs.moderationPrefs.labels[pref.label] =
                    pref.visibility;
            }
        }
        prefs.moderationPrefs.labels = remapLegacyLabels(prefs.moderationPrefs.labels);
        // automatically configure the client
        this.configureLabelersHeader(prefsArrayToLabelerDids(res.data.preferences));
        return prefs;
    }
    async setSavedFeeds(saved, pinned) {
        return updateFeedPreferences(this, () => ({
            saved,
            pinned,
        }));
    }
    async addSavedFeed(v) {
        return updateFeedPreferences(this, (saved, pinned) => ({
            saved: [...saved.filter((uri) => uri !== v), v],
            pinned,
        }));
    }
    async removeSavedFeed(v) {
        return updateFeedPreferences(this, (saved, pinned) => ({
            saved: saved.filter((uri) => uri !== v),
            pinned: pinned.filter((uri) => uri !== v),
        }));
    }
    async addPinnedFeed(v) {
        return updateFeedPreferences(this, (saved, pinned) => ({
            saved: [...saved.filter((uri) => uri !== v), v],
            pinned: [...pinned.filter((uri) => uri !== v), v],
        }));
    }
    async removePinnedFeed(v) {
        return updateFeedPreferences(this, (saved, pinned) => ({
            saved,
            pinned: pinned.filter((uri) => uri !== v),
        }));
    }
    async setAdultContentEnabled(v) {
        await updatePreferences(this, (prefs) => {
            let adultContentPref = prefs.findLast((pref) => client_1.AppBskyActorDefs.isAdultContentPref(pref) &&
                client_1.AppBskyActorDefs.validateAdultContentPref(pref).success);
            if (adultContentPref) {
                adultContentPref.enabled = v;
            }
            else {
                adultContentPref = {
                    $type: 'app.bsky.actor.defs#adultContentPref',
                    enabled: v,
                };
            }
            return prefs
                .filter((pref) => !client_1.AppBskyActorDefs.isAdultContentPref(pref))
                .concat([adultContentPref]);
        });
    }
    async setContentLabelPref(key, value, labelerDid) {
        if (labelerDid) {
            (0, syntax_1.ensureValidDid)(labelerDid);
        }
        await updatePreferences(this, (prefs) => {
            let labelPref = prefs.findLast((pref) => client_1.AppBskyActorDefs.isContentLabelPref(pref) &&
                client_1.AppBskyActorDefs.validateContentLabelPref(pref).success &&
                pref.label === key &&
                pref.labelerDid === labelerDid);
            let legacyLabelPref;
            if (labelPref) {
                labelPref.visibility = value;
            }
            else {
                labelPref = {
                    $type: 'app.bsky.actor.defs#contentLabelPref',
                    label: key,
                    labelerDid,
                    visibility: value,
                };
            }
            if (client_1.AppBskyActorDefs.isContentLabelPref(labelPref)) {
                // is global
                if (!labelPref.labelerDid) {
                    const legacyLabelValue = {
                        'graphic-media': 'gore',
                        porn: 'nsfw',
                        sexual: 'suggestive',
                    }[labelPref.label];
                    // if it's a legacy label, double-write the legacy label
                    if (legacyLabelValue) {
                        legacyLabelPref = prefs.findLast((pref) => client_1.AppBskyActorDefs.isContentLabelPref(pref) &&
                            client_1.AppBskyActorDefs.validateContentLabelPref(pref).success &&
                            pref.label === legacyLabelValue &&
                            pref.labelerDid === undefined);
                        if (legacyLabelPref) {
                            legacyLabelPref.visibility = value;
                        }
                        else {
                            legacyLabelPref = {
                                $type: 'app.bsky.actor.defs#contentLabelPref',
                                label: legacyLabelValue,
                                labelerDid: undefined,
                                visibility: value,
                            };
                        }
                    }
                }
            }
            return prefs
                .filter((pref) => !client_1.AppBskyActorDefs.isContentLabelPref(pref) ||
                !(pref.label === key && pref.labelerDid === labelerDid))
                .concat([labelPref])
                .filter((pref) => {
                if (!legacyLabelPref)
                    return true;
                return (!client_1.AppBskyActorDefs.isContentLabelPref(pref) ||
                    !(pref.label === legacyLabelPref.label &&
                        pref.labelerDid === undefined));
            })
                .concat(legacyLabelPref ? [legacyLabelPref] : []);
        });
    }
    async addLabeler(did) {
        const prefs = await updatePreferences(this, (prefs) => {
            let labelersPref = prefs.findLast((pref) => client_1.AppBskyActorDefs.isLabelersPref(pref) &&
                client_1.AppBskyActorDefs.validateLabelersPref(pref).success);
            if (!labelersPref) {
                labelersPref = {
                    $type: 'app.bsky.actor.defs#labelersPref',
                    labelers: [],
                };
            }
            if (client_1.AppBskyActorDefs.isLabelersPref(labelersPref)) {
                let labelerPrefItem = labelersPref.labelers.find((labeler) => labeler.did === did);
                if (!labelerPrefItem) {
                    labelerPrefItem = {
                        did,
                    };
                    labelersPref.labelers.push(labelerPrefItem);
                }
            }
            return prefs
                .filter((pref) => !client_1.AppBskyActorDefs.isLabelersPref(pref))
                .concat([labelersPref]);
        });
        // automatically configure the client
        this.configureLabelersHeader(prefsArrayToLabelerDids(prefs));
    }
    async removeLabeler(did) {
        const prefs = await updatePreferences(this, (prefs) => {
            let labelersPref = prefs.findLast((pref) => client_1.AppBskyActorDefs.isLabelersPref(pref) &&
                client_1.AppBskyActorDefs.validateLabelersPref(pref).success);
            if (!labelersPref) {
                labelersPref = {
                    $type: 'app.bsky.actor.defs#labelersPref',
                    labelers: [],
                };
            }
            if (client_1.AppBskyActorDefs.isLabelersPref(labelersPref)) {
                labelersPref.labelers = labelersPref.labelers.filter((labeler) => labeler.did !== did);
            }
            return prefs
                .filter((pref) => !client_1.AppBskyActorDefs.isLabelersPref(pref))
                .concat([labelersPref]);
        });
        // automatically configure the client
        this.configureLabelersHeader(prefsArrayToLabelerDids(prefs));
    }
    async setPersonalDetails({ birthDate, }) {
        birthDate = birthDate instanceof Date ? birthDate.toISOString() : birthDate;
        await updatePreferences(this, (prefs) => {
            let personalDetailsPref = prefs.findLast((pref) => client_1.AppBskyActorDefs.isPersonalDetailsPref(pref) &&
                client_1.AppBskyActorDefs.validatePersonalDetailsPref(pref).success);
            if (personalDetailsPref) {
                personalDetailsPref.birthDate = birthDate;
            }
            else {
                personalDetailsPref = {
                    $type: 'app.bsky.actor.defs#personalDetailsPref',
                    birthDate,
                };
            }
            return prefs
                .filter((pref) => !client_1.AppBskyActorDefs.isPersonalDetailsPref(pref))
                .concat([personalDetailsPref]);
        });
    }
    async setFeedViewPrefs(feed, pref) {
        await updatePreferences(this, (prefs) => {
            const existing = prefs.findLast((pref) => client_1.AppBskyActorDefs.isFeedViewPref(pref) &&
                client_1.AppBskyActorDefs.validateFeedViewPref(pref).success &&
                pref.feed === feed);
            if (existing) {
                pref = { ...existing, ...pref };
            }
            return prefs
                .filter((p) => !client_1.AppBskyActorDefs.isFeedViewPref(pref) || p.feed !== feed)
                .concat([{ ...pref, $type: 'app.bsky.actor.defs#feedViewPref', feed }]);
        });
    }
    async setThreadViewPrefs(pref) {
        await updatePreferences(this, (prefs) => {
            const existing = prefs.findLast((pref) => client_1.AppBskyActorDefs.isThreadViewPref(pref) &&
                client_1.AppBskyActorDefs.validateThreadViewPref(pref).success);
            if (existing) {
                pref = { ...existing, ...pref };
            }
            return prefs
                .filter((p) => !client_1.AppBskyActorDefs.isThreadViewPref(p))
                .concat([{ ...pref, $type: 'app.bsky.actor.defs#threadViewPref' }]);
        });
    }
    async setInterestsPref(pref) {
        await updatePreferences(this, (prefs) => {
            const existing = prefs.findLast((pref) => client_1.AppBskyActorDefs.isInterestsPref(pref) &&
                client_1.AppBskyActorDefs.validateInterestsPref(pref).success);
            if (existing) {
                pref = { ...existing, ...pref };
            }
            return prefs
                .filter((p) => !client_1.AppBskyActorDefs.isInterestsPref(p))
                .concat([{ ...pref, $type: 'app.bsky.actor.defs#interestsPref' }]);
        });
    }
    async upsertMutedWords(newMutedWords) {
        await updatePreferences(this, (prefs) => {
            let mutedWordsPref = prefs.findLast((pref) => client_1.AppBskyActorDefs.isMutedWordsPref(pref) &&
                client_1.AppBskyActorDefs.validateMutedWordsPref(pref).success);
            if (mutedWordsPref && client_1.AppBskyActorDefs.isMutedWordsPref(mutedWordsPref)) {
                for (const updatedWord of newMutedWords) {
                    let foundMatch = false;
                    const sanitizedUpdatedValue = (0, util_1.sanitizeMutedWordValue)(updatedWord.value);
                    // was trimmed down to an empty string e.g. single `#`
                    if (!sanitizedUpdatedValue)
                        continue;
                    for (const existingItem of mutedWordsPref.items) {
                        if (existingItem.value === sanitizedUpdatedValue) {
                            existingItem.targets = Array.from(new Set([...existingItem.targets, ...updatedWord.targets]));
                            foundMatch = true;
                            break;
                        }
                    }
                    if (!foundMatch) {
                        mutedWordsPref.items.push({
                            ...updatedWord,
                            value: sanitizedUpdatedValue,
                        });
                    }
                }
            }
            else {
                // if the pref doesn't exist, create it
                mutedWordsPref = {
                    items: newMutedWords.map((w) => ({
                        ...w,
                        value: (0, util_1.sanitizeMutedWordValue)(w.value),
                    })),
                };
            }
            return prefs
                .filter((p) => !client_1.AppBskyActorDefs.isMutedWordsPref(p))
                .concat([
                { ...mutedWordsPref, $type: 'app.bsky.actor.defs#mutedWordsPref' },
            ]);
        });
    }
    async updateMutedWord(mutedWord) {
        await updatePreferences(this, (prefs) => {
            const mutedWordsPref = prefs.findLast((pref) => client_1.AppBskyActorDefs.isMutedWordsPref(pref) &&
                client_1.AppBskyActorDefs.validateMutedWordsPref(pref).success);
            if (mutedWordsPref && client_1.AppBskyActorDefs.isMutedWordsPref(mutedWordsPref)) {
                for (const existingItem of mutedWordsPref.items) {
                    if (existingItem.value === mutedWord.value) {
                        existingItem.targets = mutedWord.targets;
                        break;
                    }
                }
            }
            return prefs
                .filter((p) => !client_1.AppBskyActorDefs.isMutedWordsPref(p))
                .concat([
                { ...mutedWordsPref, $type: 'app.bsky.actor.defs#mutedWordsPref' },
            ]);
        });
    }
    async removeMutedWord(mutedWord) {
        await updatePreferences(this, (prefs) => {
            const mutedWordsPref = prefs.findLast((pref) => client_1.AppBskyActorDefs.isMutedWordsPref(pref) &&
                client_1.AppBskyActorDefs.validateMutedWordsPref(pref).success);
            if (mutedWordsPref && client_1.AppBskyActorDefs.isMutedWordsPref(mutedWordsPref)) {
                for (let i = 0; i < mutedWordsPref.items.length; i++) {
                    const existing = mutedWordsPref.items[i];
                    if (existing.value === mutedWord.value) {
                        mutedWordsPref.items.splice(i, 1);
                        break;
                    }
                }
            }
            return prefs
                .filter((p) => !client_1.AppBskyActorDefs.isMutedWordsPref(p))
                .concat([
                { ...mutedWordsPref, $type: 'app.bsky.actor.defs#mutedWordsPref' },
            ]);
        });
    }
    async hidePost(postUri) {
        await updateHiddenPost(this, postUri, 'hide');
    }
    async unhidePost(postUri) {
        await updateHiddenPost(this, postUri, 'unhide');
    }
}
exports.BskyAgent = BskyAgent;
/**
 * This function updates the preferences of a user and allows for a callback function to be executed
 * before the update.
 * @param cb - cb is a callback function that takes in a single parameter of type
 * AppBskyActorDefs.Preferences and returns either a boolean or void. This callback function is used to
 * update the preferences of the user. The function is called with the current preferences as an
 * argument and if the callback returns false, the preferences are not updated.
 */
async function updatePreferences(agent, cb) {
    const res = await agent.app.bsky.actor.getPreferences({});
    const newPrefs = cb(res.data.preferences);
    if (newPrefs === false) {
        return res.data.preferences;
    }
    await agent.app.bsky.actor.putPreferences({
        preferences: newPrefs,
    });
    return newPrefs;
}
/**
 * A helper specifically for updating feed preferences
 */
async function updateFeedPreferences(agent, cb) {
    let res;
    await updatePreferences(agent, (prefs) => {
        let feedsPref = prefs.findLast((pref) => client_1.AppBskyActorDefs.isSavedFeedsPref(pref) &&
            client_1.AppBskyActorDefs.validateSavedFeedsPref(pref).success);
        if (feedsPref) {
            res = cb(feedsPref.saved, feedsPref.pinned);
            feedsPref.saved = res.saved;
            feedsPref.pinned = res.pinned;
        }
        else {
            res = cb([], []);
            feedsPref = {
                $type: 'app.bsky.actor.defs#savedFeedsPref',
                saved: res.saved,
                pinned: res.pinned,
            };
        }
        return prefs
            .filter((pref) => !client_1.AppBskyActorDefs.isSavedFeedsPref(pref))
            .concat([feedsPref]);
    });
    return res;
}
/**
 * Helper to transform the legacy content preferences.
 */
function adjustLegacyContentLabelPref(pref) {
    let visibility = pref.visibility;
    // adjust legacy values
    if (visibility === 'show') {
        visibility = 'ignore';
    }
    return { ...pref, visibility };
}
/**
 * Re-maps legacy labels to new labels on READ. Does not save these changes to
 * the user's preferences.
 */
function remapLegacyLabels(labels) {
    const _labels = { ...labels };
    const legacyToNewMap = {
        gore: 'graphic-media',
        nsfw: 'porn',
        suggestive: 'sexual',
    };
    for (const labelName in _labels) {
        const newLabelName = legacyToNewMap[labelName];
        if (newLabelName) {
            _labels[newLabelName] = _labels[labelName];
        }
    }
    return _labels;
}
/**
 * A helper to get the currently enabled labelers from the full preferences array
 */
function prefsArrayToLabelerDids(prefs) {
    const labelersPref = prefs.findLast((pref) => client_1.AppBskyActorDefs.isLabelersPref(pref) &&
        client_1.AppBskyActorDefs.validateLabelersPref(pref).success);
    let dids = [];
    if (labelersPref) {
        dids = labelersPref.labelers.map((labeler) => labeler.did);
    }
    return dids;
}
async function updateHiddenPost(agent, postUri, action) {
    await updatePreferences(agent, (prefs) => {
        let pref = prefs.findLast((pref) => client_1.AppBskyActorDefs.isHiddenPostsPref(pref) &&
            client_1.AppBskyActorDefs.validateHiddenPostsPref(pref).success);
        if (pref && client_1.AppBskyActorDefs.isHiddenPostsPref(pref)) {
            pref.items =
                action === 'hide'
                    ? Array.from(new Set([...pref.items, postUri]))
                    : pref.items.filter((uri) => uri !== postUri);
        }
        else {
            if (action === 'hide') {
                pref = {
                    $type: 'app.bsky.actor.defs#hiddenPostsPref',
                    items: [postUri],
                };
            }
        }
        return prefs
            .filter((p) => !client_1.AppBskyActorDefs.isInterestsPref(p))
            .concat([{ ...pref, $type: 'app.bsky.actor.defs#hiddenPostsPref' }]);
    });
}
function isBskyPrefs(v) {
    return (v &&
        typeof v === 'object' &&
        'moderationPrefs' in v &&
        isModPrefs(v.moderationPrefs));
}
function isModPrefs(v) {
    return v && typeof v === 'object' && 'labelers' in v;
}
//# sourceMappingURL=bsky-agent.js.map